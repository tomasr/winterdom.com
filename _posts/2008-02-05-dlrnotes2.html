---
layout: post
status: publish
published: true
title: DLR Notes 2
author:
  display_name: Tomas Restrepo
  login: tomasr
  email: tomas@winterdom.com
  url: http://winterdom.com/
author_login: tomasr
author_email: tomas@winterdom.com
author_url: http://winterdom.com/
wordpress_id: 663
wordpress_url: http://winterdom.com/2008/02/dlrnotes2
date: '2008-02-05 04:41:43 +0000'
date_gmt: '2008-02-05 04:41:43 +0000'
categories:
- ".NET"
- DLR
tags: []
comments: []
---
<p><!--start_raw-->
<p>This time I'm going to talk a bit as to how to implement function calls in the Dynamic Language Runtime. Last time, I mentioned that I had initially had implemented function definitions as simply returning a raw CodeBlockExpression. This works, but it doesn't give you many options to add custom language-specific behaviors.</p>
<p>A more useful approach in many cases is to wrap your function into an actual object, at runtime, which can then be used for different purposes (including actually invoking the function). So instead of simply moving the CodeBlockExpression around you create a subtree that creates a new object with the CodeBlockExpression as an argument (among other things) and return that instead (with possibly other actions around it, like putting it into a variable).</p>
<p>This is how both IronRuby and ToyScript do it (and I imagine, IronPython). If you look at ToyScript's Def class (the language-specific AST node for a function definition), you will this in action:</p>
<div>Ast.Assign(    <br>&nbsp; tg.GetOrMakeLocal(_name),     <br>&nbsp; Ast.Call(     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">typeof</font>(ToyFunction).GetMethod(<font color="#800000">"Create"</font>),     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ast.Constant(_name),     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ast.NewArray(<font color="#0000ff">typeof</font>(<font color="#0000ff">string</font>[]), names),     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ast.CodeBlockExpression(block, <font color="#800000">false</font>)     <br>&nbsp; )     <br>)     <br></div>
<p>As you can see, it will generate a Call expression to ToyFunction.Create(), which is a static method that returns an instance of the ToyFunction class. At runtime, ToyFunction.Create() will receive the name of the function, the names of the method parameters and a Delegate instance that can be used to actually invoke the code later on. That last part is the interesting bit.</p>
<p>So later on, you want to invoke your function. You already have a variable somewhere that evaluates to a Function object at runtime (in the case of ToyScript, a ToyFunction object as we mentioned). In more general terms, what you will have is an expression that will evaluate to the function object; it really could be anything (like another function call that returns another function). But how do you actually invoke it?</p>
<p>Turns out there are several ways you can implement this, with varying degrees of performance characteristics and needs.</p><br />
<h2>Generating Calls</h2>
<p>In the case of invoking a standalone (local or global) function you already defined in your language, the most obvious choice is to use a direct Call expression, via Ast.Call(). We already saw an example in the short snippet above, but for a different use.</p>
<p>Ast.Call() takes a System.Reflection.MethodInfo object (the method to execute) and a params array of expressions to use as arguments to the call (there are other overloads available). If the MethodInfo object points to a non-static method, then the first expression in the arguments list will be the instance [target] object on which to actually make the call.</p>
<p>This is pretty useful if you want to call methods you're aware of at compile&#47;parse time, such as a built-in function like ToyFunction.Create() above, but it's not useful at all to do what we want: Invoking a CodeBlock we created somewhere else.</p>
<p>For this we need to turn to generating a Call <em>action</em>, using Ast.Action.Call():</p>
<div><font color="#0000ff">public</font>&nbsp;<font color="#0000ff">static</font> ActionExpression Call(Type result, <font color="#0000ff">params</font> Expression[] arguments);</div>
<p>The first parameter is the type of the return value of the call; which can be typeof(object) unless you have more advanced information about what the call will return. The second argument is the list of parameter values you want to pass to the function.</p>
<p><em>...So how do you tell Call() what to actually invoke?</em></p>
<p>Yep, that tripped me up as well. Turns out that a CallAction expression expects that the first expression in the arguments list evaluates to a <em>callable object</em>. At least that's how I think of it. But what's a callable object? As I understand it, it means that it references an object that either:</p>
<ol>
<li>Implements IDynamicObject, or </li>
<li>Has a public instance method with the following signature:
<div><font color="#0000ff">object</font> Call(CodeContext context, <font color="#0000ff">params</font>&nbsp;<font color="#0000ff">object</font>[] arguments);</div>   </li> </ol>
<p>The current ToyScript incarnation follows path 2. Here's the implementation of the Call() method:</p>
<div>[SpecialName]    <br><font color="#0000ff">public</font>&nbsp;<font color="#0000ff">object</font> Call(CodeContext context, <font color="#0000ff">params</font>&nbsp;<font color="#0000ff">object</font>[] arguments) {     <br>&nbsp;&nbsp; ParameterInfo[] parameters = _target.Method.GetParameters();     <br>&nbsp;&nbsp; <font color="#0000ff">if</font> (parameters.Length > arguments.Length) {     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">if</font> ((parameters.Length > <font color="#800000">0</font> &amp;&amp; parameters[<font color="#800000">0</font>].ParameterType == <font color="#0000ff">typeof</font>(CodeContext)) ||     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_target.Target != <font color="#0000ff">null</font> &amp;&amp; _target.Method.IsStatic &amp;&amp; parameters.Length > <font color="#800000">1</font> &amp;&amp; parameters[<font color="#800000">1</font>].ParameterType == <font color="#0000ff">typeof</font>(CodeContext))) {     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arguments = ArrayUtils.Insert<<font color="#0000ff">object</font>>(context, arguments);     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }     <br>&nbsp;&nbsp; }     <br>&nbsp;&nbsp; <font color="#0000ff">return</font> ReflectionUtils.InvokeDelegate(_target, arguments);     <br>}     <br></div>
<p>The code can look a bit convoluted, but it's actually quite simple: It simple checks the actual arguments supplied to the call to see if the CodeContext has already been included explicitly in it; otherwise it adds it as the first argument, and then uses ReflectionUtils.InvokeDelegate() to actually invoke the ToyScript function represented by this instance of ToyFunction (_target is a field containing our Delegate instance). It's easy, but I think it doesn't have the best performance.</p><br />
<h2>IDynamicObject</h2>
<p>A slightly more complex implementation would instead implement IDynamicObject. This what IronRuby's Proc class does, and it's what I currently have working on my own language implementation. The core of the IDynamicObject idea is that, unlike with the special Call() method above, our function object is no longer responsible for actually doing the call on the target function. Instead, we're merely responsible for providing the DLR with a <a href="http:&#47;&#47;blogs.msdn.com&#47;mmaly&#47;archive&#47;2008&#47;01&#47;22&#47;building-a-dlr-language-dynamic-behaviors-3.aspx">rule</a> it can use to invoke it. This is exactly what you do inside your GetRule<T>() implementation.</p>
<p>In our case, what we really want is to respond with a new rule for the Call dynamic action, which is the only one we're interested in it. My current (simplistic) implementation works like this:</p>
<div><font color="#0000ff">public</font> StandardRule<T> GetRule<T>(DynamicAction action, CodeContext context, <font color="#0000ff">object</font>[] args) {     <br>&nbsp;&nbsp; <font color="#0000ff">switch</font> ( action.Kind ) {     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">case</font> DynamicActionKind.Call:     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StandardRule<T> result = <font color="#0000ff">new</font> StandardRule<T>();     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActionBinder binder = LanguageContext.Binder;     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetCallRule(r<br />
esult, binder, result.Parameters);     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">return</font> result;     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">default</font>:     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">return</font>&nbsp;<font color="#0000ff">null</font>;     <br>&nbsp;&nbsp; }     <br>}     <br>    <br><font color="#0000ff">private</font>&nbsp;<font color="#0000ff">void</font> SetCallRule(StandardRule result, ActionBinder binder, IList<Tree.Expression> args) {     <br>&nbsp;&nbsp; <font color="#008000">&#47;&#47; args[0] == this</font>     <br>&nbsp;&nbsp; result.AddTest(     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tree.Ast.Equal(     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[<font color="#800000">0</font>],     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tree.Ast.Constant(<font color="#0000ff">this</font>)     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ));     <br>    <br>&nbsp;&nbsp; Tree.Expression[] expr = <font color="#0000ff">new</font> Tree.Expression[args.Count-<font color="#800000">1</font>];     <br>&nbsp;&nbsp; <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = <font color="#800000">0</font>; i < expr.Length; i++ )     <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expr[i] = args[i+<font color="#800000">1</font>];     <br>&nbsp;&nbsp; result.Target = result.MakeReturn(binder, Tree.Ast.ComplexCallHelper(Target, expr));     <br>}     <br></div>
<p>As you can see, we create a new StandardRule but a very simple one:</p>
<ul>
<li>The <em>test</em> part of the rule simply checks that the target object on which to invoke the call is the same as our instance. This is what tells the DLR if the call should or should not be made. Here's I'm simply doing an identity test, which seems to work fine in my unit tests. IronRuby, for example, instead uses a unique ID assigned to each Proc instance for the call test. </li>
<li>The second part will create a new array with the actual arguments to the call (i.e. without the first 'this' argument) and use that to build the call using Ast.ComplexCallHelper(). </li> </ul>
<p>One we return the rule, the DLR can cache that information to make following calls more efficient, for example.</p>
<p>Something to watch out for here and that really confused me at first: If you read the above code carefully, you'll notice that the DLR Actually gives us an object[] to GetRule<T>(). This will contain the actual values of arguments to the call (not expressions that evaluate to them), so you can examine them to decide how to best to create your rule. Notice however that I don't actually use them. Instead I use the already existing expressions in StandardRule<T>.Parameters, which will be already populated with the expressions for your call arguments.</p>
<p>The reason for this is that, as it turns out, is that if you used the original values to build your own Expressions to create the test (and possibly parameters) for the call, you will run into an issue that can cause the DLR to go into an infinite recursion of nested DynamicSite.Invoke() calls. Not fun to debug, and looking at the rules or AST dumps won't tell you why it's failing. I think the relevant issue is mentioned in a comment in the DLR source code that reads <em>"The test should be such that it does not become invalid immediately. Otherwise, ActionBinder.UpdateSiteAndExecute can potentially loop infinitely."</em></p>
<p>Anyway, once you realize how Ast.Action.Call() works and what it expects from you, it all starts making a lot more sense.</p><br />
<h2>ActionBinders</h2>
<p>It is also important to note that already in these simple scenarios your language's ActionBinder implementation starts to kick in. In particular, you need to ensure that it implements the required type conversions so that the DLR can make any conversions necessary between the actual argument values to a call and the types of the parameters as declared in the CodeBlock (through ActionBinder.ConvertExpression()).</p>
<p>Next time I'll talk a bit about InvokeMember actions.</p>
<div class="wlWriterSmartContent" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:13edb6fe-9b82-4c5e-869e-76bd8966d167" style="margin: 0px; padding: 0px; display: inline;">Technorati tags: <a href="http:&#47;&#47;technorati.com&#47;tags&#47;Dynamic%20Language%20Runtime" rel="tag">Dynamic Language Runtime</a>, <a href="http:&#47;&#47;technorati.com&#47;tags&#47;DLR" rel="tag">DLR</a>, <a href="http:&#47;&#47;technorati.com&#47;tags&#47;.NET" rel="tag">.NET</a></div><hints id="hah_hints"></hints><!--end_raw--></p>
