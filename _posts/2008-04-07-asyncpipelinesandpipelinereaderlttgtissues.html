---
layout: post
status: publish
published: true
title: Async Pipelines and PipelineReader<T> Issues
author:
  display_name: Tomas Restrepo
  login: tomasr
  email: tomas@winterdom.com
  url: http://winterdom.com/
author_login: tomasr
author_email: tomas@winterdom.com
author_url: http://winterdom.com/
wordpress_id: 699
wordpress_url: http://winterdom.com/2008/04/asyncpipelinesandpipelinereaderlttgtissues
date: '2008-04-07 16:33:37 +0000'
date_gmt: '2008-04-07 16:33:37 +0000'
categories:
- ".NET"
- PowerShell
tags: []
comments: []
---
<p><!--start_raw-->
<p>I've been spending some time this week coding some changes to a custom PowerShell <a href="http:&#47;&#47;msdn2.microsoft.com&#47;en-us&#47;library&#47;system.management.automation.host.pshost(VS.85).aspx">PSHost</a> for an application. One of the changes I wanted to experiment with was changing the code that executed commands so that it used <a href="http:&#47;&#47;msdn2.microsoft.com&#47;en-us&#47;library&#47;system.management.automation.runspaces.pipeline.invokeasync(VS.85).aspx?url=&#47;library&#47;en-us&#47;WCF_con&#47;html&#47;1e8d04dd-b7cf-41e7-8560-54b4381beb0f.asp?frame=true">Pipeline.InvokeAsync()</a> instead of Pipeline.Invoke().</p>
<p>There are a couple of things that need to be handled different in this case: How you process the results from the pipeline and how you handle errors. I'll concentrate on the first one, as it is the one that caused me a bit of trouble to get right.</p>
<p>To process the results from an asynchronous pipeline invocation, you need to use a <a href="http:&#47;&#47;msdn2.microsoft.com&#47;en-us&#47;library&#47;ms551699(VS.85).aspx">PipelineReader</a><PSObject> object, which is what the Pipeline.Output property returns. This allows you to read objects generated by the pipeline execution as they are coming out (i.e. as soon as they are available) instead of waiting until the entire pipeline has executed to grab the results, so the idea is pretty nifty.</p>
<p>Unfortunately, the documentation on how to use this object correctly isn't very good. For example, you can't rely on the Count or IsOpen properties as boundary checks to detect how many items to attempt to read. In particular, the Count property isn't reliable if you're using Pipeline.InvokeAsync() because it only represents how many objects are currently available in the reader, not the total count of objects returned by the pipeline (this is natural once you realize it, but still).</p>
<p>Instead, you should really rely on the EndOfPipeline property of PipelineReader<T> to detect when you've reached the end of the object stream generated by the pipeline execution.</p>
<p>The second issue that's not very obvious is that when you use Pipeline.Invoke(), but you don't need to feed inputs to the command, then the pipeline won't really start executing until you close the PipelineWriter object returned by Pipeline.Input. If you don't do this, then PipelineReader.Read() will simply block forever.</p><br />
<h2>Phantom Objects</h2>
<p>The one nasty issue I did run is what appears to be a synchronization issue inside PipelineReader<T> itself. In my original attempt to use Pipeline.InvokeAsync(), I started getting some weird results: Ghost objects were coming out of the reader.</p>
<p>Ghost objects? </p>
<p>Pretty much, yes. Let's say I executed an "ls" command on my pipeline that should return 8 items. Sometimes, I'd indeed get the expected 8 items out of the pipeline before EndOfPipeline changed to true. Other times, however, I'd see 9 items come out of it.</p>
<p>The last item was a "ghost" object that was empty: a PSCustomObject with no properties at all. Where was it coming from?</p>
<p>The only good thing about this was that if it appeared at all, it <em>always</em> did it as the last place in the pipeline. This gave me a clue: Could this be a marker object inserted internally by PowerShell into the object stream to <em>mark the end of the pipeline</em>? It sure looked like some kind of null value.</p>
<p>. It is, in fact, <a href="http:&#47;&#47;msdn2.microsoft.com&#47;en-us&#47;library&#47;system.management.automation.internal.automationnull.value(VS.85).aspx">AutomationNull.Value</a>, which, although defined in System.Management.Automation.Internal, is a public type&#47;property. </p>
<p>The reason I say this problem is a synchronization issue is that, for the user of PipelineReader<T>, the use of this marker object should've been transparent. Instead, it is a leaking abstraction that <em>sometimes</em> (and just sometimes!) gets exposed and returned from PipelineReader.Read() when it should never happen!</p>
<p>In the end, I ended up rewriting my code like this to work around this problem:</p>
<div class="codebg"><code>PipelineReader<PSObject> results = pipeline.Output;      <br &#47;><span class="Repeat">while</span> ( !results.EndOfPipeline ) {       <br &#47;>&#160;&#160; PSObject obj = results.Read();       <br &#47;>&#160;&#160; <span class="Comment">&#47;&#47; check that the object returned isn't </span>      <br &#47;>&#160;&#160; <span class="Comment">&#47;&#47; $null, signaling the end of the pipeline</span>       <br &#47;>&#160;&#160; <span class="Conditional">if</span> ( obj != AutomationNull.Value )       <br &#47;>&#160;&#160;&#160;&#160;&#160; <span class="Comment">&#47;&#47; do something with the object</span>       <br &#47;>} </code></div>
<div class="wlWriterSmartContent" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:76b6823e-5b13-4ef3-ab93-f9afb43ecd6b" style="padding-right: 0px; display: inline; padding-left: 0px; padding-bottom: 0px; margin: 0px; padding-top: 0px">Technorati tags: <a href="http:&#47;&#47;technorati.com&#47;tags&#47;PowerShell" rel="tag">PowerShell</a>, <a href="http:&#47;&#47;technorati.com&#47;tags&#47;.NET" rel="tag">.NET</a></div><!--end_raw--></p>
