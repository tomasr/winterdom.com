---
layout: post
status: publish
published: true
title: Flow Control Classifier Sample
author:
  display_name: Tomas Restrepo
  login: tomasr
  email: tomas@winterdom.com
  url: http://winterdom.com/
author_login: tomasr
author_email: tomas@winterdom.com
author_url: http://winterdom.com/
wordpress_id: 1270
wordpress_url: http://winterdom.com/2009/06/flow-control-classifier-sample
date: '2009-06-09 02:25:32 +0000'
date_gmt: '2009-06-09 02:25:32 +0000'
categories:
- Visual Studio
tags: []
comments:
- id: 896
  author: Winterdom &raquo; Blog Archive &raquo; Classifier Sample Update
  author_email: ''
  author_url: http://winterdom.com/2009/06/classifier-sample-update
  date: '2009-06-14 18:01:43 +0000'
  date_gmt: '2009-06-14 18:01:43 +0000'
  content: "[...] been extending my Flow Control Classifier sample extension for Visual
    Studio 2010, and based on the new features, I decided to rename it to [...]"
- id: 918
  author: 'MVP Factor : Extensiones para VS2010'
  author_email: ''
  author_url: http://blogs.msdn.com/mvplead/archive/2009/06/18/extensiones-para-vs2010.aspx
  date: '2009-06-18 15:30:23 +0000'
  date_gmt: '2009-06-18 15:30:23 +0000'
  content: "[...] been extending my Flow Control Classifier sample extension for Visual
    Studio 2010, and based on the new features, I decided to rename it to [...]"
---
<p>I&rsquo;ve been doing my first experiments with extending Visual Studio 2010 beta 1 using the recently released <a href="http:&#47;&#47;msdn.microsoft.com&#47;en-us&#47;library&#47;bb166441(VS.100).aspx">SDK</a>. It&rsquo;s been lots of fun, but it can also be frustrating at times because the new extensibility model is huge and you don&rsquo;t always know where to get started.</p>
<p>My first sample extension is a custom Classifier that changes how flow control keywords get rendered in the editor in C# and C&#47;C++ so that they are easy to separate at a glance from other, more structural keywords. This is a common feature in other IDEs, but Visual Studio has always lumped all language keywords in a single category, which is a bit less useful.</p>
<p>Here&rsquo;s how code might look with the Flow Control Classifier installed (C#):</p>
<p><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="vs10_fcext_1" border="0" alt="vs10_fcext_1" src="http:&#47;&#47;winterdom.com&#47;wp-content&#47;uploads&#47;2009&#47;06&#47;vs10-fcext-1.png" width="698" height="215" &#47;> </p>
<p>One of the really nice things about how classifiers work in VS2010 is that they get recognized by the IDE automatically and new entries for any custom classificatios are added&#160; in the Fonts And Colors dialog so that the user can tweak the appearance. After installing the sample, you can adjust the settings for the &ldquo;Flow Control Keyword&rdquo; category to make the colors match your Visual Studio theme.</p>
<p>Much of the code in this sample is based on the Custom Classifier project template that comes with the VS2010 SDK, but I tweaked it quite a bit to make it easier to work with. You can find the code for the sample on the <a href="http:&#47;&#47;github.com&#47;tomasr&#47;KeywordClassifier&#47;">FlowControlClassifier repository</a> at GitHub.</p>
<p>There are some interesting aspects about this extension that are worth commenting so that I remember them later on:</p><br />
<h2>Controlling which Editors are Extended</h2>
<p>The Visual Studio extensibility model provides an easy way to control on which editors your custom classifier runs, through the [ContentType] attribute on your Classifier Provider class.</p>
<p>The default project generated by the project template specifies the &ldquo;text&rdquo; content type, which causes it to run always. However, for this sample, I changed that and added the attribute twice; once for C# (which uses the &ldquo;CSharp&rdquo; content type), and once for C++ (which uses the &ldquo;C&#47;C++&rdquo; content type). </p>
<p>The second aspect of this is, of course, checking the type of context you&rsquo;re running in at runtime. For the FlowControlClassifier, I wanted to be able to use different lists of keywords to highlight for each language. Though C# and C&#47;C++ are largely similar, this made it easier to support other languages later.</p>
<p>The way to do this is simple: When the classifier runs, I check the ContentType property of the TextBuffer instance associated to the span the classifier is currently classifying:</p>
<pre class="codebg"><code><span class="Type">string</span>[] keywords =<br />
   GetKeywordsByContentType(span.Snapshot.TextBuffer.ContentType);</code></pre></p>
<h2>Overriding the Default Look</h2></p>
<p>Another cool thing that the new classifier model provides is that the format specifications provided by classifications are merged together before rendering. That means that a single span in the editor might get classified two different ways by two different classifiers, and the editor can merge those together to produce a single look.</p></p>
<p>For example, one classifier might say it wants it in bold, while the other might only say it wants it in blue. The editor can then make the span bold and blue.</p></p>
<p>Fortunately, you can tell the editor how you want that merging process to work. In the FlowControlClassifier, I wanted to always override the default look already provided by the language service classification (i.e. the format specified in the Keyword option in the Fonts And Colors dialog). To do this, I tell VS that I want my classification format to be applied <em>after</em> the default classifier and with a high priority:</p></p>
<p><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="vs10_fcext_2" border="0" alt="vs10_fcext_2" src="http:&#47;&#47;winterdom.com&#47;wp-content&#47;uploads&#47;2009&#47;06&#47;vs10-fcext-2.png" width="574" height="46" &#47;> </p></p>
<h2>Parsing the Content</h2></p>
<p>From what I can see, the way the editor interacts with the classifier is such that you will basically get a call to your GetClassificationSpans() method for each visible line in the buffer at a given time. Although the editor gives you a span covering a single line of text at a time while, you can ask for the text before&#47;beyond the span given, though there&rsquo;s good reason to avoid doing that as much as possible.</p></p>
<p>Obviously you can&rsquo;t really rely that it will be exactly so (many things can affect when it gets called), but that does tell us a lot about how the editor works. In particular, only classifying the visible portion of the buffer should definitely keep the editor snappy when possible.</p></p>
<p>In my initial attempt at writing the classifier, I started manually parsing the text given (which can be retrieved by calling span.GetText()) to look for keywords and generate ClassificationSpans for each one I found.</p></p>
<p>This seemed to work at first, until I realized this was undesirable for a very simple reason: I couldn&rsquo;t just look for the words in the text, without being aware of the context they were used in.</p></p>
<p>For example, &ldquo;for&rdquo; is a keyword I&rsquo;m interested in, but obviously not if it appears inside a quoted string or a comment. I could work around that with a bit of work, but that even that fell apart real quick, since I couldn&rsquo;t handle multi-line comments or multi-line string literals when I was just seeing the text one line at a time. And parsing back through the buffer to check for context was simply not an appealing option.</p></p>
<p>Fortunately, after wondering aloud on twitter if there might be a way to reuse the classifications already done by the underlying language service, <a href="http:&#47;&#47;blogs.msdn.com&#47;noahric&#47;">Noah Richards</a> came to the rescue and provided a fantastic sample on how to do just that: <a href="http:&#47;&#47;gist.github.com&#47;125540">http:&#47;&#47;gist.github.com&#47;125540</a></p></p>
<p>Basically the sample shows how to call use the Classifier Aggregator service provided by the IDE, which aggregates and merges all the classifications returned by the registered classifiers, and ask it to run the classifiers on the selected span of text. Now all you have to do is go through the classifications returned, look for those the language service marked as keywords, and filter those down based on our own list.</p></p>
<p>The only tricky part about it is some work on our classifier provider implementation so that when we&rsquo;re calling into the aggregator ourselves, we exclude our own classifier from the process. Very important, otherwise we&rsquo;d get the editor stuck in an infinite recursion and blow it up real quick.</p></p>
<p>All the credit for this goes to Noah, I wouldn&rsquo;t even have known where to start to make this happen :).</p></p>
<h2>Conclusion</h2></p>
<p>All in all, I&rsquo;ve been having lots of fun working on this little extension, and I&rsquo;m looking forward to extend it to support a number of other things as well. It&rsquo;s pretty cool that you can do things like this with relative ease in the new editor, and this one is one I sure plan on using day to day.</p></p>
<p>Everything is not rosy, of course. It takes a while to get used to the extensibility model, as it&rsquo;s pretty big, and despite the support that MEF provides for hooking stuff together, you still have to be pretty careful about the values you provide in the attributes: If some things don&rsquo;t match, you might find that things don&rsquo;t work correctly and there&rsquo;s no easy way to figure out what&rsquo;s going on.</p></p>
<p><b>Update:</b> I've renamed the project to Keyword Classifier and extended it to support new features. <a href='http:&#47;&#47;winterdom.com&#47;2009&#47;06&#47;classifier-sample-update'> Details  here</a>.</p>
